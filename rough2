import numpy as np
from ahrs.filters import Madgwick
import time

# Example data - Replace these with your actual data
gyro_data = np.random.randn(1000, 3)  # Replace with actual gyroscope data (Nx3 array)
accel_data = np.random.randn(1000, 3)  # Replace with actual accelerometer data (Nx3 array)
frequency = 200  # Sampling frequency in Hz

# Initialize the Madgwick filter
madgwick = Madgwick(frequency=frequency)

# Initialize an array to store the orientation estimates
orientations = np.zeros((len(gyro_data), 4))  # Nx4 array for quaternions

def normalize(v):
    norm = np.linalg.norm(v)
    if norm == 0:
        return v
    return v / norm

# Function to ensure gravity vector aligns with the z-axis
def align_gravity(quaternion):
    # Create a gravity vector
    gravity = np.array([0.0, 0.0, 1.0])
    
    # Convert quaternion to rotation matrix
    q0, q1, q2, q3 = quaternion
    rot_matrix = np.array([
        [1 - 2*(q2**2 + q3**2), 2*(q1*q2 - q0*q3), 2*(q1*q3 + q0*q2)],
        [2*(q1*q2 + q0*q3), 1 - 2*(q1**2 + q3**2), 2*(q2*q3 - q0*q1)],
        [2*(q1*q3 - q0*q2), 2*(q2*q3 + q0*q1), 1 - 2*(q1**2 + q2**2)]
    ])
    
    # Rotate gravity vector
    estimated_gravity = np.dot(rot_matrix, gravity)
    
    # Compute correction quaternion
    v = np.cross(estimated_gravity, gravity)
    s = np.sqrt((1 + np.dot(estimated_gravity, gravity)) * 2)
    correction_quaternion = np.hstack((s / 2, v / s))
    correction_quaternion = normalize(correction_quaternion)
    
    # Apply correction
    q_corrected = quaternion_multiply(correction_quaternion, quaternion)
    return normalize(q_corrected)

def quaternion_multiply(q1, q2):
    w1, x1, y1, z1 = q1
    w2, x2, y2, z2 = q2
    return np.array([
        w1*w2 - x1*x2 - y1*y2 - z1*z2,
        w1*x2 + x1*w2 + y1*z2 - z1*y2,
        w1*y2 - x1*z2 + y1*w2 + z1*x2,
        w1*z2 + x1*y2 - y1*x2 + z1*w2
    ])

# Simulate real-time frame-by-frame processing
for i in range(len(gyro_data)):
    gyr = gyro_data[i]
    acc = normalize(accel_data[i])
    
    # Update the Madgwick filter with the new sensor data
    madgwick.updateIMU(gyr=gyr, acc=acc)
    
    # Get the current orientation as a quaternion
    quaternion = madgwick.Q
    
    # Correct the orientation to align gravity with the z-axis
    corrected_quaternion = align_gravity(quaternion)
    
    # Store the corrected orientation
    orientations[i] = corrected_quaternion
    
    # Simulate real-time delay
    time.sleep(1.0 / frequency)

# Print the estimated orientations
print("Estimated orientations (quaternions):")
print(orientations)


-----------------------------------------------------------------------


import numpy as np
from scipy.linalg import svd

# Function to convert a quaternion to a rotation matrix
def quat2rotmat(quat):
    w, x, y, z = quat
    return np.array([
        [1 - 2*y**2 - 2*z**2, 2*x*y - 2*z*w, 2*x*z + 2*y*w],
        [2*x*y + 2*z*w, 1 - 2*x**2 - 2*z**2, 2*y*z - 2*x*w],
        [2*x*z - 2*y*w, 2*y*z + 2*x*w, 1 - 2*x**2 - 2*y**2]
    ])

# Function to convert a rotation matrix to a quaternion
def rotmat2quat(rotmat):
    m = rotmat
    t = np.trace(m)
    if t > 0:
        S = np.sqrt(t+1.0) * 2
        w = 0.25 * S
        x = (m[2,1] - m[1,2]) / S
        y = (m[0,2] - m[2,0]) / S
        z = (m[1,0] - m[0,1]) / S
    elif (m[0,0] > m[1,1]) and (m[0,0] > m[2,2]):
        S = np.sqrt(1.0 + m[0,0] - m[1,1] - m[2,2]) * 2
        w = (m[2,1] - m[1,2]) / S
        x = 0.25 * S
        y = (m[0,1] + m[1,0]) / S
        z = (m[0,2] + m[2,0]) / S
    elif m[1,1] > m[2,2]:
        S = np.sqrt(1.0 + m[1,1] - m[0,0] - m[2,2]) * 2
        w = (m[0,2] - m[2,0]) / S
        x = (m[0,1] + m[1,0]) / S
        y = 0.25 * S
        z = (m[1,2] + m[2,1]) / S
    else:
        S = np.sqrt(1.0 + m[2,2] - m[0,0] - m[1,1]) * 2
        w = (m[1,0] - m[0,1]) / S
        x = (m[0,2] + m[2,0]) / S
        y = (m[1,2] + m[2,1]) / S
        z = 0.25 * S
    return np.array([w, x, y, z])

# Function to multiply two quaternions
def quaternion_multiply(q1, q2):
    w1, x1, y1, z1 = q1
    w2, x2, y2, z2 = q2
    w = w1*w2 - x1*x2 - y1*y2 - z1*z2
    x = w1*x2 + x1*w2 + y1*z2 - z1*y2
    y = w1*y2 - x1*z2 + y1*w2 + z1*x2
    z = w1*z2 + x1*y2 - y1*x2 + z1*w2
    return np.array([w, x, y, z])

# Function to compute the conjugate of a quaternion
def quaternion_conjugate(quat):
    w, x, y, z = quat
    return np.array([w, -x, -y, -z])

# Function to compute the distance between two quaternions
def quaternion_distance(q1, q2):
    q1_conj = quaternion_conjugate(q1)
    delta_q = quaternion_multiply(q1_conj, q2)
    angle = 2 * np.arccos(delta_q[0])
    return angle

# Function to align quaternions
def align_quaternions(setA, setB):
    n = setA.shape[0]
    
    # Convert quaternions to rotation matrices
    rotA = np.array([quat2rotmat(q) for q in setA])
    rotB = np.array([quat2rotmat(q) for q in setB])
    
    # Compute the matrix K
    K = np.zeros((3, 3))
    for i in range(n):
        K += np.dot(rotB[i].T, rotA[i])
    
    # Perform SVD on K
    U, S, Vt = svd(K)
    R_opt = np.dot(U, Vt)
    
    # Ensure a proper rotation (det(R_opt) = 1)
    if np.linalg.det(R_opt) < 0:
        Vt[2, :] *= -1
        R_opt = np.dot(U, Vt)
    
    # Convert the optimal rotation matrix to a quaternion
    q_opt = rotmat2quat(R_opt)
    
    return q_opt

# Generate a random quaternion set A
def random_quaternion():
    u1, u2, u3 = np.random.uniform(0, 1, 3)
    q = np.array([
        np.sqrt(1-u1) * np.sin(2*np.pi*u2),
        np.sqrt(1-u1) * np.cos(2*np.pi*u2),
        np.sqrt(u1) * np.sin(2*np.pi*u3),
        np.sqrt(u1) * np.cos(2*np.pi*u3)
    ])
    return q / np.linalg.norm(q)

# Number of quaternions
n = 10
setA = np.array([random_quaternion() for _ in range(n)])

# Ground truth rotation quaternion
q_gt = random_quaternion()

# Apply the ground truth rotation to create set B
setB = np.array([quaternion_multiply(q_gt, q) for q in setA])

# Estimate the optimal quaternion
q_opt = align_quaternions(setA, setB)

# Compute the alignment error
alignment_error = quaternion_distance(q_gt, q_opt)

print("Ground Truth Quaternion (q_gt):", q_gt)
print("Optimal Quaternion (q_opt):", q_opt)
print("Alignment Error (in radians):", alignment_error)

